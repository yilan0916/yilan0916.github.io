<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Docker基础篇"><meta name="keywords" content="Java,框架,docker"><meta name="author" content="yilan0916,yilan0916@gmail.com"><meta name="copyright" content="yilan0916"><title>Docker基础篇 | yilan0916's Blogs</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">Docker简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89docker%E5%87%BA%E7%8E%B0"><span class="toc-number">1.1.</span> <span class="toc-text">为什么会有docker出现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.</span> <span class="toc-text">是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.1.</span> <span class="toc-text">传统虚拟机技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.2.</span> <span class="toc-text">容器虚拟化技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.3.</span> <span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-number">1.3.</span> <span class="toc-text">能干嘛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E8%81%8C%E7%BA%A7%E5%8F%98%E5%8C%96"><span class="toc-number">1.3.1.</span> <span class="toc-text">技术职级变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91-x2F-%E8%BF%90%E7%BB%B4%EF%BC%88Dev-x2F-Ops%EF%BC%89%E6%96%B0%E4%B8%80%E4%BB%A3%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88"><span class="toc-number">1.3.2.</span> <span class="toc-text">开发&#x2F;运维（Dev&#x2F;Ops）新一代开发工程师</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%BB%E5%93%AA%E4%B8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">去哪下</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E5%AE%89%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">Docker安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">前提条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">2.2.</span> <span class="toc-text">Docker的基本组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%EF%BC%88image%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">镜像（image）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%EF%BC%88container%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">容器（container）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%93%E5%BA%93%EF%BC%88repository%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">仓库（repository）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.4.</span> <span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%E5%9B%BE%E8%A7%A3"><span class="toc-number">2.3.</span> <span class="toc-text">Docker平台架构图解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E6%98%93%E7%89%88"><span class="toc-number">2.3.1.</span> <span class="toc-text">简易版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E7%89%88"><span class="toc-number">2.3.2.</span> <span class="toc-text">架构版</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.4.</span> <span class="toc-text">安装步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F"><span class="toc-number">2.5.</span> <span class="toc-text">Docker下载加速</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B0%B8%E8%BF%9C%E7%9A%84HelloWord"><span class="toc-number">2.6.</span> <span class="toc-text">永远的HelloWord</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">2.7.</span> <span class="toc-text">底层原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.</span> <span class="toc-text">Docker常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%AE%E5%8A%A9%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="toc-number">3.1.</span> <span class="toc-text">帮助启动类命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">3.2.</span> <span class="toc-text">镜像命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.3.</span> <span class="toc-text">容器命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.4.</span> <span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F"><span class="toc-number">4.</span> <span class="toc-text">Docker镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.1.</span> <span class="toc-text">镜像是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">4.2.</span> <span class="toc-text">分层的镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">Docker镜像加载原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">4.4.</span> <span class="toc-text">镜像分层的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%B1%82"><span class="toc-number">4.5.</span> <span class="toc-text">容器层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8Fcommit%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.6.</span> <span class="toc-text">Docker镜像commit操作实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93-2"><span class="toc-number">4.7.</span> <span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91"><span class="toc-number">5.</span> <span class="toc-text">本地镜像发布到阿里云</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Registry%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BB%93"><span class="toc-number">6.</span> <span class="toc-text">Registry搭建私仓</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">7.</span> <span class="toc-text">Docker容器数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%E4%B8%8A%E4%B8%80%E8%8A%82%E7%9A%84%E5%8F%82%E6%95%B0-v"><span class="toc-number">7.1.</span> <span class="toc-text">回顾上一节的参数-v</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">7.2.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B-1"><span class="toc-number">7.3.</span> <span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%A1%88%E4%BE%8B"><span class="toc-number">7.4.</span> <span class="toc-text">数据卷案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BF%E4%B8%BBvs%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E6%98%A0%E5%B0%84%E6%B7%BB%E5%8A%A0%E5%AE%B9%E5%99%A8%E5%8D%B7"><span class="toc-number">7.4.1.</span> <span class="toc-text">宿主vs容器之间映射添加容器卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E8%A7%84%E5%88%99%E6%98%A0%E5%B0%84%E6%B7%BB%E5%8A%A0%E8%AF%B4%E6%98%8E"><span class="toc-number">7.4.2.</span> <span class="toc-text">读写规则映射添加说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B7%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E5%85%B1%E4%BA%AB"><span class="toc-number">7.4.3.</span> <span class="toc-text">卷的继承和共享</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E5%B8%B8%E8%A7%84%E5%AE%89%E8%A3%85%E7%AE%80%E4%BB%8B"><span class="toc-number">8.</span> <span class="toc-text">Docker常规安装简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="toc-number">8.1.</span> <span class="toc-text">总体步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85tomcat"><span class="toc-number">8.2.</span> <span class="toc-text">安装tomcat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85mysql"><span class="toc-number">8.3.</span> <span class="toc-text">安装mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%89%88"><span class="toc-number">8.3.1.</span> <span class="toc-text">简单版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E7%89%88"><span class="toc-number">8.3.2.</span> <span class="toc-text">实战版</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85redis"><span class="toc-number">8.4.</span> <span class="toc-text">安装redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%89%88-1"><span class="toc-number">8.4.1.</span> <span class="toc-text">简单版</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E7%89%88-1"><span class="toc-number">8.5.</span> <span class="toc-text">实战版</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85nginx"><span class="toc-number">8.6.</span> <span class="toc-text">安装nginx</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99"><span class="toc-number">9.</span> <span class="toc-text">学习资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">yilan0916</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="http://github.com/yilan0916">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">39</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">46</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">51</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接-Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.csdn.net/qwqwdqwqwe">MYCSDN</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">yilan0916's Blogs</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/history">运营历史</a><a class="site-page" href="/gallery">画廊</a><a class="site-page" href="/about">关于作者</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Docker基础篇</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/%E6%A1%86%E6%9E%B6/">框架</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/%E6%A1%86%E6%9E%B6/docker/">docker</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">8.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 29 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="为什么会有docker出现"><a href="#为什么会有docker出现" class="headerlink" title="为什么会有docker出现"></a>为什么会有docker出现</h2><p>项目开发完成之后，需求将其从dev迁移到test、prod环境。安装和环境配置相当麻烦，换一台机器就要重新来一次，费时费力。很多人想到，能不能从根本上解决问题，&#x3D;&#x3D;软件可以带环境安装？&#x3D;&#x3D;，也就是说，&#x3D;&#x3D;安装的时候，把原始环境一模一样地复制过来&#x3D;&#x3D;。</p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Docker是基于Go语言实现的云开源项目。</p>
<p>Docker的主要目标是：<code>Build, Ship and Run Any App, Anywhere</code>，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到&#x3D;&#x3D;<strong>一次镜像,处处运行</strong>。&#x3D;&#x3D;</p>
<p>一句话：解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</p>
<h3 id="传统虚拟机技术"><a href="#传统虚拟机技术" class="headerlink" title="传统虚拟机技术"></a>传统虚拟机技术</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。</p>
<p>它可以在一种操作系统里面运行另一种操作系统，比如在Windows10系统里面运行Linux系统CentOS7。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。</p>
<p>缺点：资源占用多、冗余步骤多、启动慢</p>
<h3 id="容器虚拟化技术"><a href="#容器虚拟化技术" class="headerlink" title="容器虚拟化技术"></a>容器虚拟化技术</h3><p>Linux容器是与系统其他部分分隔开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p>
<p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一的运行。</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>大小</td>
<td>一般为MB</td>
<td>一般为GB</td>
</tr>
<tr>
<td>速度</td>
<td>接近原生</td>
<td>比较慢</td>
</tr>
<tr>
<td>系统支持数量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody></table>
<h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><h3 id="技术职级变化"><a href="#技术职级变化" class="headerlink" title="技术职级变化"></a>技术职级变化</h3><p>coder -&gt; programer -&gt; software engineer -&gt; DevOps engineer</p>
<h3 id="开发-x2F-运维（Dev-x2F-Ops）新一代开发工程师"><a href="#开发-x2F-运维（Dev-x2F-Ops）新一代开发工程师" class="headerlink" title="开发&#x2F;运维（Dev&#x2F;Ops）新一代开发工程师"></a>开发&#x2F;运维（Dev&#x2F;Ops）新一代开发工程师</h3><p>一次构建、随处运行</p>
<ul>
<li>更快速的应用交付和部署<blockquote>
<p>传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。</p>
</blockquote>
</li>
<li>更便捷的升级和扩容<blockquote>
<p>随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。</p>
</blockquote>
</li>
<li>更简单的系统运维<blockquote>
<p>应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。</p>
</blockquote>
</li>
<li>更高效的计算资源利用<blockquote>
<p>Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。</p>
</blockquote>
</li>
</ul>
<h2 id="去哪下"><a href="#去哪下" class="headerlink" title="去哪下"></a>去哪下</h2><p>docker官网：<a target="_blank" rel="noopener" href="https://www.docker.com/">https://www.docker.com/</a><br>docker hub官网：<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在CentOS 7 (64-bit)上，</p>
<p>要求系统为64位、Linux系统内核版本为 3.8以上，这里选用Centos7.x</p>
<p>查看系统内核版本：</p>
<blockquote>
<p>cat &#x2F;etc&#x2F;redhat-release</p>
</blockquote>
<h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h2><h3 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a>镜像（image）</h3><p>Docker 镜像（Image）就是一个<strong>只读</strong>的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。</p>
<p>它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。</p>
<p>相当于容器的“源代码”，docker镜像文件类似于Java的类模板，而docker容器实例类似于java中new出来的实例对象。</p>
<h3 id="容器（container）"><a href="#容器（container）" class="headerlink" title="容器（container）"></a>容器（container）</h3><p>1、从面向对象角度</p>
<p>Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台</p>
<p>2、从镜像容器角度</p>
<p>**<em>可以把容器看做是一个简易版的 Linux 环境</em>**（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>
<h3 id="仓库（repository）"><a href="#仓库（repository）" class="headerlink" title="仓库（repository）"></a>仓库（repository）</h3><p>仓库（Repository）是集中存放镜像文件的场所。</p>
<p>类似于<br>    Maven仓库，存放各种jar包的地方；<br>    github仓库，存放各种git项目的地方；</p>
<p>Docker公司提供的官方registry被称为Docker Hub，存放各种镜像模板的地方。</p>
<p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p>
<p>最大的公开仓库是 Docker Hub(<a target="_blank" rel="noopener" href="https://hub.docker.com/)%EF%BC%8C">https://hub.docker.com/)，</a></p>
<p>存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>需要正确的理解仓库&#x2F;镜像&#x2F;容器这几个概念:</p>
<blockquote>
<p>Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。</p>
</blockquote>
<blockquote>
<p>image文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>
</blockquote>
<p>镜像文件： image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</p>
<p>容器实例：一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</p>
<p>仓库：就是放一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候再从仓库中拉下来就可以了。</p>
<h2 id="Docker平台架构图解"><a href="#Docker平台架构图解" class="headerlink" title="Docker平台架构图解"></a>Docker平台架构图解</h2><h3 id="简易版"><a href="#简易版" class="headerlink" title="简易版"></a>简易版</h3><p><img src="https://images2017.cnblogs.com/blog/517566/201707/517566-20170729175104738-1807206908.png" alt="简易版"></p>
<p>原理：Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。</p>
<h3 id="架构版"><a href="#架构版" class="headerlink" title="架构版"></a>架构版</h3><p><img src="https://img-blog.csdnimg.cn/61e1710f36a847e18a70ca8522cadd74.png" alt="架构版"></p>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>网址：<a target="_blank" rel="noopener" href="https://docs.docker.con/engine/install/centos/">https://docs.docker.con/engine/install/centos/</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">1、确定是CentOS7及以上版本</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">2、卸载旧版本(如果安装过的话)</span><br><span class="line">sudo yum remove docker \</span><br><span class="line">		  docker-client \</span><br><span class="line">		  docker-client-latest \</span><br><span class="line">		  docker-common \</span><br><span class="line">		  docker-latest \</span><br><span class="line">		  docker-latest-logrotate \</span><br><span class="line">		  docker-logrotate \</span><br><span class="line">		  docker-engine</span><br><span class="line">3、yum安装gcc相关</span><br><span class="line">sudo yum -y install gcc</span><br><span class="line">sudo yum -y install gcc-c++</span><br><span class="line">4、安装需要的软件包</span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line">5、设置stable镜像仓库</span><br><span class="line">推荐使用第二个阿里云镜像地址</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">6、创建缓存（可选）</span><br><span class="line">sudo yum makecache fast</span><br><span class="line">7、安装最新版本的Docker引擎、Docker客户端</span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br><span class="line"></span><br><span class="line">安装其他版本</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询版本列表</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本安装17.09.0.ce版</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin</span></span><br><span class="line">sudo yum install docker-ce-17.09.0.ce docker-ce-cli-17.09.0.ce containerd.io docker-compose-plugin</span><br><span class="line"></span><br><span class="line">8、启动docker</span><br><span class="line">systemctl start docker   //新版本的Docker就是一个系统服务，可以直接使用启动系统服务方式启动</span><br><span class="line"></span><br><span class="line">9、测试</span><br><span class="line">docker version     //此时查看docker版本</span><br><span class="line">docker run hello-word</span><br><span class="line"></span><br><span class="line">10、卸载</span><br><span class="line">systemctl stop docker    //关闭服务</span><br><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io  //使用yum删除docker引擎</span><br><span class="line">sudo rm -rf /var/lib/docker    //删除镜像、容器、卷、自定义配置等文件</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>

<p>tips：在linux中,sudo全称“super user do”,意思为“干超级用户才能干的事”,是一个系统权限管理命令,可以让非root的用户运行只有root才有权限执行的命令</p>
<h2 id="Docker下载加速"><a href="#Docker下载加速" class="headerlink" title="Docker下载加速"></a>Docker下载加速</h2><p>方式1：使用网易数帆、阿里云等容器镜像仓库进行下载。</p>
<p>例如，下载网易数帆镜像中的mysql。（网易数帆的地址为 <code>hub.c.163.com</code>，网易数帆对dockerhub官方的镜像命名空间为 <code>library</code>）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hub.c.163.com/library/mysql:latest</span><br></pre></td></tr></table></figure>

<p>方式2：配置阿里云加速</p>
<p>登录阿里云，进入 <code>工作台</code> -&gt; <code>容器镜像服务</code> -&gt; <code>镜像工具</code> -&gt; <code>镜像加速器</code>。<br>里面提供了一个加速器地址：<code>https://xxxxx.mirror.aliyuncs.com</code>，将该地址配置到docker中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初次进来时没有/etc/docker/daemon.json文件，直接创建该文件即可</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">daemon.json中填入</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://xxxxx.mirror.aliyuncs.com&quot;]  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后刷新配置、重启docker即可</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">centos7 的命令</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line">使用方式2可以直接下载官方的镜像，且镜像tag为官方tag，不需要加上云服务商的地址。</span><br><span class="line">docker pull mysql:latest</span><br></pre></td></tr></table></figure>

<h2 id="永远的HelloWord"><a href="#永远的HelloWord" class="headerlink" title="永远的HelloWord"></a>永远的HelloWord</h2><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>Docker运行速度快的原因：</p>
<blockquote>
<p>1、Docker有比虚拟机更少的抽象层：<br>由于Docker不需要Hypervisor（虚拟机）实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在CPU、内存利用率上docker有明显优势。<br>2、Docker利用的是宿主机的内核，而不需要加载操作系统OS内核：<br>当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较耗时耗资源的过程。当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个docker容器只需要几秒钟。<br>3、Docker容器的本质就是一个进程。</p>
</blockquote>
<h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><h2 id="帮助启动类命令"><a href="#帮助启动类命令" class="headerlink" title="帮助启动类命令"></a>帮助启动类命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">启动docker：</span><br><span class="line">systemctl start docker</span><br><span class="line">停止Docker：</span><br><span class="line">systemctl stop docker</span><br><span class="line">重启Docker：</span><br><span class="line">systemctl restart docker</span><br><span class="line">查看状态：</span><br><span class="line">systemctl status docker</span><br><span class="line">设置开机自启：</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line">查看Docker版本：</span><br><span class="line">docker version</span><br><span class="line">查看Docker概要信息：</span><br><span class="line">docker info</span><br><span class="line">查看Docker总体帮助文档：</span><br><span class="line">docker --help</span><br><span class="line">查看docker具体命令帮助文档：</span><br><span class="line">docker 具体命令 --help</span><br></pre></td></tr></table></figure>

<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">列出本地主机上的镜像:</span><br><span class="line">docker images   //参数 -a:列出所有镜像（含历史镜像） -q:只显示镜像ID -f:过滤</span><br><span class="line">在远程仓库中搜索镜像：</span><br><span class="line">docker search 镜像名称   //参数 -f:过滤 --limit 数量:只展示前几项</span><br><span class="line">下载镜像</span><br><span class="line">docker pull 镜像名称[:tag]   //不加 tag 时，默认下载最新的镜像（即tag为`latest`）</span><br><span class="line">查看镜像/容器/数据卷所占的空间：</span><br><span class="line">docker system df</span><br><span class="line"></span><br><span class="line">删除镜像:</span><br><span class="line">docker rmi 镜像名称/ID</span><br><span class="line">可以使用空格分隔，删除多个镜像：</span><br><span class="line">docker rmi 镜像1 镜像2 镜像3</span><br><span class="line">删除全部镜像：</span><br><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure>

<p>面试题：谈谈docker虚悬镜像是什么？</p>
<p>仓库名、标签都是<code>&lt;none&gt;</code>的镜像，俗称虚悬镜像（dangling image）。后续Dockerfile章节再介绍</p>
<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>有镜像才能创建容器，这是根本前提（下载一个centos或者ubuntu镜像演示）<br><strong>注意：是运行在Docker上的Ubuntu</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">新建+启动容器：</span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">  常用的参数：--name：为容器指定一个名称</span><br><span class="line">             -d：后台运行容器并返回容器ID，也即启动守护式容器</span><br><span class="line">             -i：以交互模式（interactive）运行容器，通常与`-t`同时使用</span><br><span class="line">             -t：为容器重新分配一个伪输入终端（tty），通常与`-i`同时使用。也即启动交互式容器（前台有伪终端，等待交互）</span><br><span class="line">             -e：为容器添加环境变量</span><br><span class="line">             -P：随机端口映射。将容器内暴露的所有端口映射到宿主机随机端口</span><br><span class="line">             -p：指定端口映射</span><br><span class="line">             </span><br><span class="line">    -p指定端口映射的几种不同形式：</span><br><span class="line">      -p hostPort:containerPort：端口映射，例如`-p 8080:80`</span><br><span class="line">      -p ip:hostPort:containerPort：配置监听地址，例如 `-p 10.0.0.1:8080:80`</span><br><span class="line">      -p ip::containerPort：随机分配端口，例如 `-p 10.0.0.1::80`</span><br><span class="line">      -p hostPort1:containerPort1 -p hostPort2:containerPort2：指定多个端口映射，例如`-p 8080:80 -p 8888:3306`</span><br><span class="line"></span><br><span class="line">启动ubuntu交互式容器：</span><br><span class="line">docker run -it ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line">两种退出容器的方式：</span><br><span class="line"> exit 退出后，容器会停止</span><br><span class="line"> ctrl + p + q 推出后容器依然正在运行</span><br><span class="line"></span><br><span class="line">列出正在运行的容器：</span><br><span class="line">docker ps [OPTIONS]   //参数 -a：列出当前所有正在运行的容器+历史上运行过的容器 -l：显示最近创建的容器 -n：显示最近n个创建的容器  -q：静默模式，只显示容器编号</span><br><span class="line"></span><br><span class="line">启动已经停止的容器：</span><br><span class="line">docker start 容器ID或容器名</span><br><span class="line">重启容器：</span><br><span class="line">docker restart 容器ID或容器名</span><br><span class="line">停止容器：</span><br><span class="line">docker stop 容器ID或容器名</span><br><span class="line">强制停止容器：</span><br><span class="line">docker kill 容器ID或容器名</span><br><span class="line"></span><br><span class="line">删除已经停止的容器：</span><br><span class="line">docker rm 容器ID或容器名</span><br><span class="line">强制删除正在运行的容器：</span><br><span class="line">docker rm -f 容器ID或容器名</span><br><span class="line">一次删除多个容器实例：</span><br><span class="line">docker rm -f $&#123;docker ps -a -q&#125;</span><br><span class="line">或者 docker ps -a -q | xargs docker rm</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;重要&#x3D;&#x3D;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">大部分情况下，我们系统docker容器服务时在后台运行的，可以通过`-d`指定容器的后台运行模式</span><br><span class="line"></span><br><span class="line">启动守护式容器：</span><br><span class="line">docker run -d 容器名 </span><br><span class="line"></span><br><span class="line">redis演示前后台启动</span><br><span class="line">  前台交互式启动 dcoker run -it redis:6.0.8</span><br><span class="line">  后台交互式启动 docker run -d redis:6.0.8</span><br><span class="line"></span><br><span class="line">查看容器日志:</span><br><span class="line">docker logs 容器ID或容器名</span><br><span class="line">查看容器内运行的进程:</span><br><span class="line">docker top 容器ID或容器名</span><br><span class="line">查看容器内部细节:</span><br><span class="line">docker inspect 容器ID或容器名</span><br><span class="line"></span><br><span class="line">进入正在运行的容器:</span><br><span class="line">docker exec -it 容器ID或容器名 /bin/bash</span><br><span class="line">重新进入：</span><br><span class="line">docker attach 容器ID</span><br><span class="line">  上面两条命令的区别：</span><br><span class="line">    `attach`直接进入容器启动命令的终端，不会启动新的进程，用`exit`退出会导致容器的停止</span><br><span class="line">    `exec`是在容器中打开新的终端，并且可以启动新的进程，用`exit`退出不会导致容器的停止</span><br><span class="line">    推荐使用 exec</span><br></pre></td></tr></table></figure>

<p>文件拷贝和导入导出容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">容器内文件拷贝到宿主机：</span><br><span class="line">docker cp 容器ID:容器内路径 目的主机路径</span><br><span class="line">宿主机文件拷贝到容器中：</span><br><span class="line">docker cp 主机路径 容器ID:容器内路径</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`export`：导出容器的内容流作为一个tar归档文件（对应`import`命令）</span><br><span class="line">`import`：从tar包中的内容创建一个新的文件系统再导入为镜像（对应`export`命令）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">export</span> 容器ID &gt; tar文件名</span></span><br><span class="line">docker export abc &gt; aaa.tar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> tar文件 | docker import - 自定义镜像用户/自定义镜像名:自定义镜像版本号</span></span><br><span class="line">cat aaa.tar | docker import - test/mytest:1.0.1</span><br></pre></td></tr></table></figure>

<h2 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12911942/1652093386636-41aec8f5-bd52-4a99-8c3c-daa61c1d78a5.png" alt="Docker命令总结"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像</span><br><span class="line"></span><br><span class="line">build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像</span><br><span class="line"></span><br><span class="line">commit    Create a new image from a container changes   # 提交当前容器为新的镜像</span><br><span class="line"></span><br><span class="line">cp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line"></span><br><span class="line">create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器</span><br><span class="line"></span><br><span class="line">diff      Inspect changes on a container&#x27;s filesystem   # 查看 docker 容器变化</span><br><span class="line"></span><br><span class="line">events    Get real time events from the server          # 从 docker 服务获取容器实时事件</span><br><span class="line"></span><br><span class="line">exec      Run a command in an existing container        # 在已存在的容器上运行命令</span><br><span class="line"></span><br><span class="line">export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span><br><span class="line"></span><br><span class="line">history   Show the history of an image                  # 展示一个镜像形成历史</span><br><span class="line"></span><br><span class="line">images    List images                                   # 列出系统当前镜像</span><br><span class="line"></span><br><span class="line">import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</span><br><span class="line"></span><br><span class="line">info      Display system-wide information               # 显示系统相关信息</span><br><span class="line"></span><br><span class="line">inspect   Return low-level information on a container   # 查看容器详细信息</span><br><span class="line"></span><br><span class="line">kill      Kill a running container                      # kill 指定 docker 容器</span><br><span class="line"></span><br><span class="line">load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]</span><br><span class="line"></span><br><span class="line">login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器</span><br><span class="line"></span><br><span class="line">logout    Log out from a Docker registry server          # 从当前 Docker registry 退出</span><br><span class="line"></span><br><span class="line">logs      Fetch the logs of a container                 # 输出当前容器日志信息</span><br><span class="line"></span><br><span class="line">port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口</span><br><span class="line"></span><br><span class="line">pause     Pause all processes within a container        # 暂停容器</span><br><span class="line"></span><br><span class="line">ps        List containers                               # 列出容器列表</span><br><span class="line"></span><br><span class="line">pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line"></span><br><span class="line">push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器</span><br><span class="line"></span><br><span class="line">restart   Restart a running container                   # 重启运行的容器</span><br><span class="line"></span><br><span class="line">rm        Remove one or more containers                 # 移除一个或者多个容器</span><br><span class="line"></span><br><span class="line">rmi       Remove one or more images       # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br><span class="line"></span><br><span class="line">run       Run a command in a new container              # 创建一个新的容器并运行一个命令</span><br><span class="line"></span><br><span class="line">save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]</span><br><span class="line"></span><br><span class="line">search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像</span><br><span class="line"></span><br><span class="line">start     Start a stopped containers                    # 启动容器</span><br><span class="line"></span><br><span class="line">stop      Stop a running containers                     # 停止容器</span><br><span class="line"></span><br><span class="line">tag       Tag an image into a repository                # 给源中镜像打标签</span><br><span class="line"></span><br><span class="line">top       Lookup the running processes of a container   # 查看容器中运行的进程信息</span><br><span class="line"></span><br><span class="line">unpause   Unpause a paused container                    # 取消暂停容器</span><br><span class="line"></span><br><span class="line">version   Show the docker version information           # 查看 docker 版本号</span><br><span class="line"></span><br><span class="line">wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值</span><br></pre></td></tr></table></figure>

<h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><p><strong>镜像</strong>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。<br>只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。</p>
<h2 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h2><p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载</p>
<h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。<br>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<p>Docker镜像加载原理：docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。<br>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接使用Host的Kernel，自己只需要提供rootfs就可以。所以，对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，不同的发行版可以共用bootfs。</p>
<h2 id="镜像分层的优势"><a href="#镜像分层的优势" class="headerlink" title="镜像分层的优势"></a>镜像分层的优势</h2><p>镜像分层的一个最大好处就是共享资源，方便复制迁移，方便复用。</p>
<h2 id="容器层"><a href="#容器层" class="headerlink" title="容器层"></a>容器层</h2><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>
<p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。</p>
<p>只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p>
<h2 id="Docker镜像commit操作实例"><a href="#Docker镜像commit操作实例" class="headerlink" title="Docker镜像commit操作实例"></a>Docker镜像commit操作实例</h2><p>docker commit 提交容器副本使之成为一个新的镜像<br>docker commit -m&#x3D;”提交的描述信息” -a&#x3D;”作者” 容器ID 要创建的目标镜像名:[tag]</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">从hub下载ubuntu到本地并成功运行：</span><br><span class="line">docker pull ubuntu</span><br><span class="line">docker run -it ubuntu</span><br><span class="line"></span><br><span class="line">原始的ubuntu镜像是不带vim命令：</span><br><span class="line">vim a.txt  //会报错, bash: vim: command not found</span><br><span class="line"></span><br><span class="line">安装vim：</span><br><span class="line">apt-get update</span><br><span class="line">apt-get -y install vim</span><br><span class="line"></span><br><span class="line">commit自己的新镜像：</span><br><span class="line">exit 退出容器层</span><br><span class="line">docker commit -m=&quot;add vim cmd&quot; -a=&quot;yilan&quot; 388ca1aeb56c atguigu/myubuntu:1.1</span><br><span class="line">docker images  //找到提交的新镜像</span><br><span class="line"></span><br><span class="line">和原来的对比：</span><br><span class="line">docker run -it atguigu/myubuntu:1.1</span><br><span class="line">vim a.txt  //能够正常进去</span><br></pre></td></tr></table></figure>

<h2 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h2><p>Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。</p>
<p>新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p>
<h1 id="本地镜像发布到阿里云"><a href="#本地镜像发布到阿里云" class="headerlink" title="本地镜像发布到阿里云"></a>本地镜像发布到阿里云</h1><p>1、进入阿里云，选择容器镜像服务<br><a target="_blank" rel="noopener" href="https://www.aliyun.com/product/acr">https://www.aliyun.com/product/acr</a></p>
<p>2、创建个人实例、命名空间和仓库名称</p>
<p>3、阿里云操作指南</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker login --username=t_1500521630964_0476 registry.cn-hangzhou.aliyuncs.com</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/yilan0916/myubuntu:[镜像版本号]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker push registry.cn-hangzhou.aliyuncs.com/yilan0916/myubuntu:[镜像版本号]</span></span><br></pre></td></tr></table></figure>

<p>4、将镜像推送到阿里云registry</p>
<p>![[Pasted image 20230513202902.png]]</p>
<p>5、从阿里云拉取</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull registry.cn-hangzhou.aliyuncs.com/yilan0916/myubuntu:[镜像版本号]</span></span><br></pre></td></tr></table></figure>


<h1 id="Registry搭建私仓"><a href="#Registry搭建私仓" class="headerlink" title="Registry搭建私仓"></a>Registry搭建私仓</h1><p>Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。</p>
<p>Docker Registry是官方提供的工具，可以用于构建私有镜像仓库</p>
<p>1、下载镜像Docker Registry</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure>
<p>2、运行私有库Registry，相当于本地有个私有DockerHub</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v /yilan/myregistry/:/tmp/registry --privileged=true registry</span><br></pre></td></tr></table></figure>
<p>3、演示创建一个新镜像，ubuntu安装ifconfig命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash</span><br><span class="line">ifconfig //报错 bash: ifconfig: command not found</span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install net-tools</span><br><span class="line">ctrl+p+q 退出</span><br><span class="line"></span><br><span class="line">docker ps    //找到ubuntu的id</span><br><span class="line">docker commit -m=&quot;ifconfig cmd add&quot; -a=&quot;yilan&quot; 6b9bff5a6bc3 mybuntu:1.2</span><br><span class="line">docker images //找到提交的镜像</span><br><span class="line"></span><br><span class="line">docker run -it mybuntu:1.2 /bin/bash</span><br><span class="line">ifconfig  //检查功能</span><br><span class="line">exit 退出</span><br></pre></td></tr></table></figure>
<p>4、curl验证私服库上有什么镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifconfig查询宿主机的ip，填入下面</span><br><span class="line">curl -XGET http://172.17.0.1:5000/v2/_catalog</span><br><span class="line">返回 &#123;&quot;repositories&quot;:[]&#125;</span><br></pre></td></tr></table></figure>
<p>5、将新镜像mybuntu:1.2修改为符合私服规范的Tag</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">按照公式： docker tag  镜像:Tag   Host:Port/Repository:Tag</span><br><span class="line"></span><br><span class="line">自己host主机IP地址，填写同学你们自己的，不要粘贴错误，O(∩_∩)O</span><br><span class="line"></span><br><span class="line">使用命令 docker tag 将zzyyubuntu:1.2 这个镜像修改为192.168.111.162:5000/zzyyubuntu:1.2</span><br><span class="line"></span><br><span class="line">docker tag mybuntu:1.2 172.17.0.1:5000/mybuntu:1.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>6、修改配置文件使之支持http<br>&#x3D;&#x3D;注意添加逗号，配置文件是json格式的&#x3D;&#x3D;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">查看</span><br><span class="line">cat /etc/docker/daemon.json</span><br><span class="line">修改</span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://aa25jngu.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;172.17.0.1:5000&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上述理由：docker默认不允许http方式推送镜像，通过配置选项来取消这个限制。====&gt; 修改完后如果不生效，建议重启docker</span><br><span class="line">systemctl restart docker</span><br><span class="line">重启docker后需要重新运行registry</span><br><span class="line">docker run -d -p 5000:5000 -v /yilan/myregistry/:/tmp/registry --privileged=true registry</span><br></pre></td></tr></table></figure>
<p>7、push到私服库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 172.17.0.1:5000/mybuntu:1.2</span><br></pre></td></tr></table></figure>
<p>8、验证</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http://172.17.0.1:5000/v2/_catalog</span><br><span class="line">返回 &#123;&quot;repositories&quot;:[&quot;mybuntu&quot;]&#125;</span><br><span class="line"></span><br><span class="line">拉取</span><br><span class="line">docker pull 172.17.0.1:5000/mybuntu:1.2</span><br></pre></td></tr></table></figure>


<h1 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h1><p>坑：容器卷记得加入–privileged&#x3D;true<br>Docker挂载主机目录访问如果出现cannot open directory .: Permission denied<br>解决办法：在挂载目录后多加一个–privileged&#x3D;true参数即可<br>如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，<br>在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用–privileged&#x3D;true命令，扩大容器的权限解决挂载目录没有权限的问题，也即使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</p>
<h2 id="回顾上一节的参数-v"><a href="#回顾上一节的参数-v" class="headerlink" title="回顾上一节的参数-v"></a>回顾上一节的参数-v</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v /yilan/myregistry/:/tmp/registry --privileged=true registry</span><br></pre></td></tr></table></figure>
<p>默认情况，仓库被创建在容器的&#x2F;var&#x2F;lib&#x2F;registry目录下，建议自行用容器卷映射，方便与宿主机联调</p>
<h2 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h2><p>一句话：有点类似我们Redis里面的rdb和aof文件<br>将docker容器内的数据保存进宿主机的磁盘中</p>
<p>运行一个带有容器卷存储功能的容器实例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure>

<h2 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a>能干嘛</h2><p>将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是持久化的</p>
<p>Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。<br>为了能保存数据在docker中我们使用卷。</p>
<p>特点：<br>1：数据卷可在容器之间共享或重用数据<br>2：卷中的更改可以直接实时生效，爽<br>3：数据卷中的更改不会包含在镜像的更新中<br>4：数据卷的生命周期一直持续到没有容器使用它为止</p>
<h2 id="数据卷案例"><a href="#数据卷案例" class="headerlink" title="数据卷案例"></a>数据卷案例</h2><h3 id="宿主vs容器之间映射添加容器卷"><a href="#宿主vs容器之间映射添加容器卷" class="headerlink" title="宿主vs容器之间映射添加容器卷"></a>宿主vs容器之间映射添加容器卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">直接添加</span><br><span class="line">docker run -it --privileged=true -v /tmp/host_data:/tmp/docker_data --name=u1 ubuntu</span><br><span class="line">cd /tmp/docker_data</span><br><span class="line">touch dockerin.txt</span><br><span class="line"></span><br><span class="line">双向数据绑定，一方修改另一方也跟着变。即使容器停止运行，重新开启时也会同步</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看数据卷是否挂载成功</span><br><span class="line">docker inspect 容器ID</span><br><span class="line">返回 &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/tmp/host_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/tmp/docker_data&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="读写规则映射添加说明"><a href="#读写规则映射添加说明" class="headerlink" title="读写规则映射添加说明"></a>读写规则映射添加说明</h3><p>1、读写（默认）<br>默认同上案例</p>
<p>2、只读</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/容器目录:ro 镜像名               就能完成功能，此时容器自己只能读取不能写</span><br><span class="line"></span><br><span class="line">ro = read only</span><br><span class="line"></span><br><span class="line">此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。</span><br><span class="line"></span><br><span class="line">完整命令</span><br><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</span><br></pre></td></tr></table></figure>

<h3 id="卷的继承和共享"><a href="#卷的继承和共享" class="headerlink" title="卷的继承和共享"></a>卷的继承和共享</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=true --volumes-from 父类 --name=u2 ubuntu</span><br></pre></td></tr></table></figure>

<h1 id="Docker常规安装简介"><a href="#Docker常规安装简介" class="headerlink" title="Docker常规安装简介"></a>Docker常规安装简介</h1><h2 id="总体步骤"><a href="#总体步骤" class="headerlink" title="总体步骤"></a>总体步骤</h2><ul>
<li>搜索镜像</li>
<li>拉取镜像</li>
<li>查看镜像</li>
<li>启动镜像 使用-p服务端口映射</li>
<li>停止容器</li>
<li>移除容器</li>
</ul>
<h2 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker search tomcat</span><br><span class="line">dokcer pull tomcat</span><br><span class="line">docker images tomcat</span><br><span class="line">返回 tomcat       latest    fb5657adc892   16 months ago   680MB</span><br><span class="line"></span><br><span class="line">docker run -it -p 8080:8080 tomcat</span><br><span class="line">或者用-d运行</span><br><span class="line"></span><br><span class="line">localhost:8080 访问出现404</span><br><span class="line">docker exec -it 7cfe0a2a164d /bin/bash</span><br><span class="line">ls -l  找到webapps，发现里面是空的</span><br><span class="line"></span><br><span class="line">解决办法</span><br><span class="line">cd ..</span><br><span class="line">rm -r webapps</span><br><span class="line">mv webapps.dist webapps</span><br><span class="line">curl -XGET http://localhost:8080/ 访问成功</span><br><span class="line">注意localhost可以换成 http://10.0.4.13:8080/ 或者 http://172.17.0.1:8080/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">免修改版说明</span><br><span class="line">docker pull billygoo/tomcat8jdk8</span><br><span class="line">docker run -d -p 8080:8080 --name mytomcat8 billygoo/tomcat8jdk8</span><br></pre></td></tr></table></figure>

<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><h3 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br><span class="line">docker ps</span><br><span class="line">docker exec -it 容器ID /bin/bash</span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line">create database db01;</span><br><span class="line">use db01;</span><br><span class="line">create table t1(id int, name varchar(20));</span><br><span class="line">insert into t1 values(1,&#x27;yilan&#x27;);</span><br><span class="line">select * from t1;</span><br><span class="line"></span><br><span class="line">show variables like &#x27;character%&#x27;;</span><br><span class="line">返回的字符集中，`character_set_database`、`character_set_server`等都为`latin1`字符集，所以会报错。</span><br><span class="line"></span><br><span class="line">INSERT INTO t1 VALUES(2,&#x27;li4&#x27;);</span><br><span class="line">INSERT INTO t1 VALUES(5,&#x27;王五&#x27;);</span><br><span class="line"></span><br><span class="line">首先在腾讯云的控制板打开mysql的防火墙</span><br><span class="line">使用数据库工具连接docker中的mysql时，要用外网ip</span><br><span class="line"></span><br><span class="line">存在的问题：</span><br><span class="line">   不能插入中文数据 docker上默认字符集编码隐患</span><br><span class="line">   删除容器后，里面的mysql数据怎么办</span><br></pre></td></tr></table></figure>

<h3 id="实战版"><a href="#实战版" class="headerlink" title="实战版"></a>实战版</h3><p>1、启动mysql容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 \</span><br><span class="line">           --privileged=true \</span><br><span class="line">           -v /app/mysql/log:/var/log/mysql \</span><br><span class="line">           -v /app/mysql/data:/var/lib/mysql \</span><br><span class="line">           -v /app/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">           -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">           --name mysql \</span><br><span class="line">           mysql:5.7</span><br></pre></td></tr></table></figure>

<p>2、在&#x2F;app&#x2F;mysql&#x2F;conf下新建my.cnf</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd /app/mysql/conf</span><br><span class="line">vim my.cnf</span><br><span class="line"></span><br><span class="line">my.cnf内容如下：</span><br><span class="line">[client]</span><br><span class="line">default_character_set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server = utf8_general_ci</span><br><span class="line">character_set_server = utf8</span><br><span class="line"></span><br><span class="line">cat my.cnf</span><br></pre></td></tr></table></figure>

<p>3、重启mysql容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure>
<p>结论：docker安装完MySQL并run出容器后，建议请先修改完字符集编码后再新建mysql库-表-插数据</p>
<h2 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h2><h3 id="简单版-1"><a href="#简单版-1" class="headerlink" title="简单版"></a>简单版</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:6.0.8</span><br><span class="line">docker images redis</span><br><span class="line">docker run -p 6379:6379 -d redis:6.0.8</span><br><span class="line">docker exec -it eb9aebfcc1c0 /bin/bash</span><br><span class="line"></span><br><span class="line">root@eb9aebfcc1c0:/data# redis-cli</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;v1&quot;</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<h2 id="实战版-1"><a href="#实战版-1" class="headerlink" title="实战版"></a>实战版</h2><p>1、宿主机创建目录 &#x2F;app&#x2F;redis</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /app/redis</span><br></pre></td></tr></table></figure>

<p>2、在app&#x2F;redis下创建文件redis.conf,主要修改以下几项配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 开启密码验证（可选）</span><br><span class="line">requirepass 123</span><br><span class="line"></span><br><span class="line"># 允许redis外地连接，需要注释掉绑定的IP</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 关闭保护模式（可选）</span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"># 注释掉daemonize yes，或者配置成 daemonize no。因为该配置和 docker run中的 -d 参数冲突，会导致容器一直启动失败</span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"># 开启redis数据持久化， （可选）</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>3、启动docker容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis --privileged=true \</span><br><span class="line">           -v /app/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">           -v /app/redis/data:/data \</span><br><span class="line">           -d redis:6.0.8 \</span><br><span class="line">           redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>
<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>见高级篇Portainer</p>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a target="_blank" rel="noopener" href="https://www.yuque.com/tmfl/cloud/ixlgsl">https://www.yuque.com/tmfl/cloud/ixlgsl</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gr4y1U7CY">https://www.bilibili.com/video/BV1gr4y1U7CY</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:yilan0916@gmail.com">yilan0916</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yilan0916.github.io/2023/05/12/Blogs/Java/Docker/Docker基础篇/">https://yilan0916.github.io/2023/05/12/Blogs/Java/Docker/Docker基础篇/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yilan0916.github.io">yilan0916's Blogs</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a><a class="post-meta__tags" href="/tags/docker/">docker</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/05/14/Blogs/Java/Docker/Docker%E9%AB%98%E7%BA%A7%E7%AF%87/"><i class="fa fa-chevron-left">  </i><span>Docker高级篇</span></a></div><div class="next-post pull-right"><a href="/2023/05/07/Blogs/Java/%E5%B7%A5%E5%85%B7%E5%8C%85/Swagger/"><span>Swagger</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '9ffd1e4033bdf26f61b2',
  clientSecret: '40d17299ec8cb68e1ab56dd11a08f730fdc50d09',
  repo: 'yilan0916.github.io',
  owner: 'yilan0916',
  admin: 'yilan0916',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2022 - 2023 By yilan0916</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>