<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spring Data JPA"><meta name="keywords" content="Java,Spring,Spring Data JPA"><meta name="author" content="yilan0916,yilan0916@gmail.com"><meta name="copyright" content="yilan0916"><title>Spring Data JPA | yilan0916's Blogs</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Data-JPA-%E5%88%9D%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">Spring Data JPA 初识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">实体类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dao%E5%B1%82"><span class="toc-number">1.2.</span> <span class="toc-text">dao层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#controller%E5%B1%82"><span class="toc-number">1.3.</span> <span class="toc-text">controller层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%90%88mysql%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.4.</span> <span class="toc-text">整合mysql数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">1.5.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ORM%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.</span> <span class="toc-text">ORM框架对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis"><span class="toc-number">1.6.1.</span> <span class="toc-text">Mybatis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hibernate"><span class="toc-number">1.6.2.</span> <span class="toc-text">Hibernate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Data-JPA"><span class="toc-number">1.6.3.</span> <span class="toc-text">Spring Data JPA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.6.4.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E8%AE%A4%E8%AF%86JPA"><span class="toc-number">1.7.</span> <span class="toc-text">整体认识JPA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Data%E8%AE%A4%E8%AF%86"><span class="toc-number">1.8.</span> <span class="toc-text">Spring Data认识</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Data-Commons%E7%9A%84Repository%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">Spring Data Commons的Repository接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JpaRepository"><span class="toc-number">2.1.</span> <span class="toc-text">JpaRepository</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SimpleJpaRepository"><span class="toc-number">2.2.</span> <span class="toc-text">SimpleJpaRepository</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DQM%E7%9A%84%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%8F%82%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">DQM的命令语法与参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E6%9F%A5%E8%AF%A2%E7%AD%96%E7%95%A5%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">方法的查询策略设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DQM%E8%AF%AD%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">DQM语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%EF%BC%9ASort%E6%8E%92%E5%BA%8F%E5%92%8CPageable%E5%88%86%E9%A1%B5"><span class="toc-number">3.3.</span> <span class="toc-text">特定类型参数：Sort排序和Pageable分页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9CFirst%E5%92%8CTop"><span class="toc-number">3.4.</span> <span class="toc-text">限制查询结果First和Top</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Null%E5%8F%82%E6%95%B0%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.5.</span> <span class="toc-text">Null参数注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%99%E6%88%91%E4%BB%AC%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83"><span class="toc-number">3.6.</span> <span class="toc-text">给我们的一些思考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Repository%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A7%A3%E5%86%B3%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">Repository的方法返回值解决实际问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9EList-x2F-Stream-x2F-Page-x2F-Slice"><span class="toc-number">4.1.</span> <span class="toc-text">如何返回List&#x2F;Stream&#x2F;Page&#x2F;Slice</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Repository-%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%B9%E5%BC%82%E6%AD%A5%E8%BF%9B%E8%A1%8C%E6%94%AF%E6%8C%81"><span class="toc-number">4.2.</span> <span class="toc-text">Repository 的方法是如何对异步进行支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Repository-%E5%AF%B9Reactive-%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E7%9A%84"><span class="toc-number">4.3.</span> <span class="toc-text">Repository 对Reactive 是如何支持的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E6%94%AF%E6%8C%81%E6%80%BB%E7%BB%93"><span class="toc-number">4.4.</span> <span class="toc-text">返回结果支持总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84DTO%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">4.5.</span> <span class="toc-text">最常见的DTO返回结果的支持</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Query%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">@Query注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E6%BA%90%E7%A0%81"><span class="toc-number">5.1.</span> <span class="toc-text">注解源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JPQL-%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">JPQL 的语法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number">6.</span> <span class="toc-text">附录</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">yilan0916</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="http://github.com/yilan0916">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">47</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">54</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">59</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接-Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.csdn.net/qwqwdqwqwe">MYCSDN</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">yilan0916's Blogs</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/history">运营历史</a><a class="site-page" href="/gallery">画廊</a><a class="site-page" href="/about">关于作者</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Spring Data JPA</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/Spring/">Spring</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/Spring/Spring-Data-JPA/">Spring Data JPA</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">7.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 30 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Spring-Data-JPA-初识"><a href="#Spring-Data-JPA-初识" class="headerlink" title="Spring Data JPA 初识"></a>Spring Data JPA 初识</h1><h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>  </span><br><span class="line"><span class="meta">@Data</span>  </span><br><span class="line"><span class="meta">@Builder</span>  </span><br><span class="line"><span class="meta">@AllArgsConstructor</span>  </span><br><span class="line"><span class="meta">@NoArgsConstructor</span>  </span><br><span class="line"><span class="meta">@Table(name = &quot;user&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;  </span><br><span class="line">	<span class="meta">@Id</span>  </span><br><span class="line">	<span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>  </span><br><span class="line">	<span class="keyword">private</span> Long id;  </span><br><span class="line">	<span class="keyword">private</span> String name;  </span><br><span class="line">	<span class="keyword">private</span> String email;  </span><br><span class="line">	<span class="keyword">private</span> String phone;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GenerationType，JPA提供的四种标准用法为TABLE,SEQUENCE,IDENTITY,AUTO</p>
<blockquote>
<ul>
<li>TABLE：使用一个特定的数据库表格来保存主键。</li>
<li>SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。</li>
<li>IDENTITY：主键由数据库自动生成（主要是自动增长型）</li>
<li>AUTO：主键由程序控制。</li>
</ul>
</blockquote>
<h2 id="dao层"><a href="#dao层" class="headerlink" title="dao层"></a>dao层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>  </span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/api/v1/user&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;  </span><br><span class="line">  </span><br><span class="line">	<span class="meta">@PostMapping(path = &quot;/save&quot;, consumes = &#123;MediaType.APPLICATION_JSON_VALUE&#125;)</span>  </span><br><span class="line">	<span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title function_">addUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;  </span><br><span class="line">		<span class="type">User</span> <span class="variable">save</span> <span class="operator">=</span> userRepository.save(user);  </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(save, HttpStatus.OK);  </span><br><span class="line">	  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整合mysql数据库"><a href="#整合mysql数据库" class="headerlink" title="整合mysql数据库"></a>整合mysql数据库</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.jpa.hibernate.ddl-auto:update</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他属性</span></span><br><span class="line"><span class="string">create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。</span></span><br><span class="line"><span class="string">create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。</span></span><br><span class="line"><span class="string">update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据</span> <span class="string">model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等</span> <span class="string">应用第一次运行起来后才会。</span></span><br><span class="line"><span class="string">validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</span></span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepositoryTest</span> &#123;  </span><br><span class="line">  </span><br><span class="line">	<span class="meta">@Autowired</span>  </span><br><span class="line">	<span class="keyword">private</span> UserRepository userRepository;  </span><br><span class="line">	<span class="meta">@Test</span>  </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> &#123;  </span><br><span class="line">		<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.save(User.builder().name(<span class="string">&quot;jack002&quot;</span>).email(<span class="string">&quot;jack002&#x27;s email&quot;</span>).build());  </span><br><span class="line">		Assert.notNull(user, <span class="string">&quot;user插入失败&quot;</span>);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="ORM框架对比"><a href="#ORM框架对比" class="headerlink" title="ORM框架对比"></a>ORM框架对比</h2><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><blockquote>
<p>优点：着力于POJO与SQL之间到映射关系，可以进行更为细致的SQL编写操作，使用起来十分灵活，上手简单</p>
<p>缺点：工作量比较大，需要各种配置文件和SQL语句</p>
</blockquote>
<h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><blockquote>
<p>优点：对JDBC进行了轻量级封装，使得程序员可以随心所欲的使用对象编程思想来操纵数据库<br>          对象有自己的生命周期，着力点为对象与对象之间关系<br>          有自己的HQL查询语言，所以数据库移植性很好<br>          Hibernate是完备的ORM框架，是符合JPA规范的，有自己的缓存机制</p>
<p>缺点：上手比较难，比较适合企业级的应用开发</p>
</blockquote>
<h3 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h3><blockquote>
<p>优点：可以理解为JPA规范的再次封装抽象，底层还是使用了Hibernate的JPA技术实现，引用JPQL（Java Persistence Query Language）查询语言，属于Spring的整个生态体系的一部分<br>           由于SpringBoot和Cloud，开发者不需要关心和配置更多东西，完成可以沉浸在Spring的完整生态标准下<br>           上手简单，开发效率高，对对象支持比较好，有很大的灵活性，市场认可度越来越高</p>
<p>缺点：入手简单，上手比较快，但想要精通就需要了解很多知识</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>OpenJPA、QueryDSL</p>
<h2 id="整体认识JPA"><a href="#整体认识JPA" class="headerlink" title="整体认识JPA"></a>整体认识JPA</h2><p><img src="https://raw.githubusercontent.com/yilan0916/picture/main/202306100945281.png" alt="截屏2023-06-10 09.42.39.png"></p>
<h2 id="Spring-Data认识"><a href="#Spring-Data认识" class="headerlink" title="Spring Data认识"></a>Spring Data认识</h2><p>Spring Data Common是Spring Data所有模块的公共部分，提供给基于Spring的共享基础设施，提供基于repository接口以及DB操作的一些封装</p>
<p>它的子项目包括Commons、JDBC、JPA、Redis、MongoDB、Elasticsearch、REST、Neo4j(图数据库)等</p>
<h1 id="Spring-Data-Commons的Repository接口"><a href="#Spring-Data-Commons的Repository接口" class="headerlink" title="Spring Data Commons的Repository接口"></a>Spring Data Commons的Repository接口</h1><p>Repository是Spring Data Common里面的顶级父类接口，操作DB的入口类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Indexed</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Repository</span>&lt;T, ID&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>七大Repository接口：</p>
<ul>
<li>Repository，没有暴露任何方法</li>
<li>CrudRepository，简单的crud方法</li>
<li>PagingAndSortingRepository，带分页和排序的方法</li>
<li>QueryByExampleExecutor，简单的Example查询</li>
<li>JpaRepository，JPA的扩展方法</li>
<li>JpaSpecificationExecutor，JpaSpecification扩展查询</li>
<li>QuerydslPredicateExecutor，QueryDsl的封装</li>
</ul>
<p>两大Repository实现类</p>
<ul>
<li>SimpleJpaRepository，JPA所有接口的默认实现类</li>
<li>QuerydslJpaRepository，Querydsl的实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CrudRepository的save和deleteById的实现逻辑</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增或者保存</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>  </span><br><span class="line"><span class="keyword">public</span> &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">save</span><span class="params">(S entity)</span> &#123;  </span><br><span class="line">	Assert.notNull(entity, <span class="string">&quot;Entity must not be null.&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.entityInformation.isNew(entity)) &#123;  </span><br><span class="line">		<span class="built_in">this</span>.em.persist(entity);  </span><br><span class="line">		<span class="keyword">return</span> entity;  </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.em.merge(entity);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(ID id)</span> &#123;  </span><br><span class="line">	Assert.notNull(id, <span class="string">&quot;The given id must not be null!&quot;</span>);  </span><br><span class="line">	<span class="built_in">this</span>.delete(<span class="built_in">this</span>.findById(id).orElseThrow(() -&gt; &#123;  </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmptyResultDataAccessException</span>(String.format(<span class="string">&quot;No %s entity with id %s exists!&quot;</span>, <span class="built_in">this</span>.entityInformation.getJavaType(), id), <span class="number">1</span>);  </span><br><span class="line">	&#125;));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中发现，update、delete、insert等操作之前读会判断是否存在该对象，JPA底层都考虑到了。所以我们在使用的时候不要画蛇添足，当我们使用任何第三方方法的时候应该先查一下其源码和逻辑或者API，然后写出优雅的代码</p>
<h2 id="JpaRepository"><a href="#JpaRepository" class="headerlink" title="JpaRepository"></a>JpaRepository</h2><p><img src="https://raw.githubusercontent.com/yilan0916/picture/main/202306101832996.png" alt="截屏2023-06-10 18.31.39.png"></p>
<ol>
<li>JpaRepository新增了批量删除，优化了批量删除的性能，不再是for循环删除</li>
<li>flush和saveAndFlush提供了手动刷新session，把对象立即更新到数据库里面<blockquote>
<p>我们都知道，JPA是由Hibernate实现的，所以有session一级缓存的机制，当调用save()方法时，数据库是不会立刻更新的</p>
</blockquote>
</li>
</ol>
<h2 id="SimpleJpaRepository"><a href="#SimpleJpaRepository" class="headerlink" title="SimpleJpaRepository"></a>SimpleJpaRepository</h2><p>关系数据库的所有Repository接口的实现类就是SimpleJpaRepository，如果有些业务场景需要进行扩展，可以继续继承此类。如果将此类里面的实现方法看透了，基本上JPA中的API就能掌握大部分内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span>  </span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleJpaRepository</span>&lt;T, ID&gt; <span class="keyword">implements</span> <span class="title class_">JpaRepositoryImplementation</span>&lt;T, ID&gt; &#123;  </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_MUST_NOT_BE_NULL</span> <span class="operator">=</span> <span class="string">&quot;The given id must not be null!&quot;</span>;  </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> JpaEntityInformation&lt;T, ?&gt; entityInformation;  </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> EntityManager em;  </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> PersistenceProvider provider;  </span><br><span class="line">	<span class="meta">@Nullable</span>  </span><br><span class="line">	<span class="keyword">private</span> CrudMethodMetadata metadata;  </span><br><span class="line">	<span class="keyword">private</span> EscapeCharacter escapeCharacter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过此类的源码，我们可以清晰地看出SimpleJpaRepository的实现机制，是通过EntityManager进行实体操作，而JpaEntityInformation里面存实体的相关信息和crud方法的元数据等</p>
<p>Spring利用动态代理帮我们生成实现类。可以在RepositoryFactorySupport设置一个断点，启动的时候，在断点处发现UserRepository的接口会被动态代理成SimpleJpaRepository的实现。<br><img src="https://raw.githubusercontent.com/yilan0916/picture/main/202306101851391.png" alt="截屏2023-06-10 18.50.24.png"></p>
<h1 id="DQM的命令语法与参数"><a href="#DQM的命令语法与参数" class="headerlink" title="DQM的命令语法与参数"></a>DQM的命令语法与参数</h1><p>Spring Data JPA的最大特色是利用方法名查询方法（Defineing Query Methods）来做CRUD操作。</p>
<p>Spring Data JPA的Defineing Query Methods（DQM）通过方法名和参数，让方法名的语意更清晰，提升开发效率。DMQ语法有两种：<br>一种是直接通过方法名就可以实现，另一种是@Query手动做方法上定义。</p>
<p>如果不想暴露CrudRepository里面的所有方法，那么可以继承我们认为需要暴露的那些方法的接口。进行选择性暴露CRUD方法，直接继承Repository（因为这里面没有任何方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyBaseRepository</span>&lt;T, ID <span class="keyword">extends</span> <span class="title class_">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;T, ID&gt; &#123;</span><br><span class="line">	T <span class="title function_">findOne</span><span class="params">(ID id)</span>;</span><br><span class="line">	T <span class="title function_">save</span><span class="params">(T entity)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">MyBaseRepostiry</span>&lt;User, Long&gt; &#123;</span><br><span class="line">	User <span class="title function_">findByEmailAddress</span><span class="params">(String emailAddress)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面代码，这样做Service层只有findOne、save、findByEmailAddress这3个方法可以调用，不会有更多的方法了。</p>
<p>综上所述，得出2点结论：</p>
<ul>
<li>MyRepository extends Repository即可偶可以实现Defining Query Methods的功能</li>
<li>继承其他Repository的子接口或者自定义接口，可以选择性地暴露SimpleJpaRepository里面已经实现的基础公用方法</li>
</ul>
<h2 id="方法的查询策略设置"><a href="#方法的查询策略设置" class="headerlink" title="方法的查询策略设置"></a>方法的查询策略设置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般不需要修改</span></span><br><span class="line"><span class="meta">@EnableJpaRepository(queryLookupStrategy=QueryLookupStrategy.KEY.CREATE_IF_NOT_FOUND)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>QueryLookupStrategy.KEY有3个值：<br>CREATE：直接根据方法名进行创建，规则是根据方法名称的构造进行解析。如果方法名不符合规则，启动时会报异常。这种情况即时配置了@Query也是没有用的。<br>USE_DECLARED_QUERY：声明方式创建，启动时会尝试找到一个声明的查询，如果没有找到将抛出一个异常，可以理解为必须配置@Query<br>CREATE_IF_NOT_FOUND：这是默认的，可以理解为上面两种的兼容版。先用@Query进行查找，如果没有找到与方法匹配的查询，那用Create的方法名创建一个查询，如果两种都不满足，启动就会报错</p>
</blockquote>
<h2 id="DQM语法"><a href="#DQM语法" class="headerlink" title="DQM语法"></a>DQM语法</h2><p>该语法时：带查询功能的方法名时由查询策略（关键字）+查询字段+一些限制性条件组成</p>
<p><img src="https://raw.githubusercontent.com/yilan0916/picture/main/202306111031231.png" alt="image.png"></p>
<p>综上，总结3点经验：</p>
<ul>
<li>方法名的表达式通常是实体属性连接运算符的组合，如And、Or、Between、LessThan、Like等属性连接运算表达式，不同数据库（NoSQL、MySQL）可能产生的效果不一样，我们可以打开SQL日志观察</li>
<li>IgnoreCase可以针对单个属性（如findByLastnameIgnoreCase），也可以针对查询条件里面所有的实体属性忽略大小写（所有属性必须值String情况下，如findByLastnameAndFirstnameAllIgnoreCase）</li>
<li>OrderBy可以值某些属性的排序上提供方向（Asc或Desc），称为静态排序，也可以通过一个方便的参数Sort实现制定字段的动态排序的查询方法（如<code>userRepository.findAll(Sort.by(Sort.Direction.ASC,&quot;firstname&quot;));</code>）</li>
</ul>
<p>除了find开头的方法，还有read、get、query、stream、count、exists、delete、remove等前缀</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;  </span><br><span class="line">	<span class="type">long</span> <span class="title function_">countByName</span><span class="params">(String name)</span>; <span class="comment">//查询总数  </span></span><br><span class="line">	<span class="type">long</span> <span class="title function_">deleteByName</span><span class="params">(String name)</span>; <span class="comment">//根据一个字段进行删除操作，并返回删除行数  </span></span><br><span class="line">	List&lt;User&gt; <span class="title function_">removeByName</span><span class="params">(String name)</span>; <span class="comment">//根据字段删除一堆User，并返回删除的User  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语法源码<br><img src="https://raw.githubusercontent.com/yilan0916/picture/main/202306111142656.png" alt="截屏2023-06-11 11.42.22.png"></p>
<p>Part.Type源码中规定了DQM语法的关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">    BETWEEN(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsBetween&quot;</span>, <span class="string">&quot;Between&quot;</span>&#125;),</span><br><span class="line">    IS_NOT_NULL(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsNotNull&quot;</span>, <span class="string">&quot;NotNull&quot;</span>&#125;),</span><br><span class="line">    IS_NULL(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsNull&quot;</span>, <span class="string">&quot;Null&quot;</span>&#125;),</span><br><span class="line">    LESS_THAN(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsLessThan&quot;</span>, <span class="string">&quot;LessThan&quot;</span>&#125;),</span><br><span class="line">    LESS_THAN_EQUAL(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsLessThanEqual&quot;</span>, <span class="string">&quot;LessThanEqual&quot;</span>&#125;),</span><br><span class="line">    GREATER_THAN(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsGreaterThan&quot;</span>, <span class="string">&quot;GreaterThan&quot;</span>&#125;),</span><br><span class="line">    GREATER_THAN_EQUAL(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsGreaterThanEqual&quot;</span>, <span class="string">&quot;GreaterThanEqual&quot;</span>&#125;),</span><br><span class="line">    BEFORE(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsBefore&quot;</span>, <span class="string">&quot;Before&quot;</span>&#125;),</span><br><span class="line">    AFTER(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsAfter&quot;</span>, <span class="string">&quot;After&quot;</span>&#125;),</span><br><span class="line">    NOT_LIKE(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsNotLike&quot;</span>, <span class="string">&quot;NotLike&quot;</span>&#125;),</span><br><span class="line">    LIKE(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsLike&quot;</span>, <span class="string">&quot;Like&quot;</span>&#125;),</span><br><span class="line">    STARTING_WITH(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsStartingWith&quot;</span>, <span class="string">&quot;StartingWith&quot;</span>, <span class="string">&quot;StartsWith&quot;</span>&#125;),</span><br><span class="line">    ENDING_WITH(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsEndingWith&quot;</span>, <span class="string">&quot;EndingWith&quot;</span>, <span class="string">&quot;EndsWith&quot;</span>&#125;),</span><br><span class="line">    IS_NOT_EMPTY(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsNotEmpty&quot;</span>, <span class="string">&quot;NotEmpty&quot;</span>&#125;),</span><br><span class="line">    IS_EMPTY(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsEmpty&quot;</span>, <span class="string">&quot;Empty&quot;</span>&#125;),</span><br><span class="line">    NOT_CONTAINING(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsNotContaining&quot;</span>, <span class="string">&quot;NotContaining&quot;</span>, <span class="string">&quot;NotContains&quot;</span>&#125;),</span><br><span class="line">    CONTAINING(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsContaining&quot;</span>, <span class="string">&quot;Containing&quot;</span>, <span class="string">&quot;Contains&quot;</span>&#125;),</span><br><span class="line">    NOT_IN(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsNotIn&quot;</span>, <span class="string">&quot;NotIn&quot;</span>&#125;),</span><br><span class="line">    IN(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsIn&quot;</span>, <span class="string">&quot;In&quot;</span>&#125;),</span><br><span class="line">    NEAR(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsNear&quot;</span>, <span class="string">&quot;Near&quot;</span>&#125;),</span><br><span class="line">    WITHIN(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsWithin&quot;</span>, <span class="string">&quot;Within&quot;</span>&#125;),</span><br><span class="line">    REGEX(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;MatchesRegex&quot;</span>, <span class="string">&quot;Matches&quot;</span>, <span class="string">&quot;Regex&quot;</span>&#125;),</span><br><span class="line">    EXISTS(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Exists&quot;</span>&#125;),</span><br><span class="line">    TRUE(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsTrue&quot;</span>, <span class="string">&quot;True&quot;</span>&#125;),</span><br><span class="line">    FALSE(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsFalse&quot;</span>, <span class="string">&quot;False&quot;</span>&#125;),</span><br><span class="line">    NEGATING_SIMPLE_PROPERTY(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;IsNot&quot;</span>, <span class="string">&quot;Not&quot;</span>&#125;),</span><br><span class="line">    SIMPLE_PROPERTY(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Is&quot;</span>, <span class="string">&quot;Equals&quot;</span>&#125;);</span><br><span class="line">....&#125;</span><br></pre></td></tr></table></figure>


<h2 id="特定类型参数：Sort排序和Pageable分页"><a href="#特定类型参数：Sort排序和Pageable分页" class="headerlink" title="特定类型参数：Sort排序和Pageable分页"></a>特定类型参数：Sort排序和Pageable分页</h2><p>Sort 里面就决定了我们哪些字段的排序方向（ASC正序，DESC倒叙）。<br>Sort源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Sort</span><span class="params">(Direction direction, List&lt;String&gt; properties)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span> (properties == <span class="literal">null</span> || properties.isEmpty()) &#123;  </span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;You have to provide at least one property to sort by!&quot;</span>);  </span><br><span class="line">	&#125;  </span><br><span class="line">	  </span><br><span class="line">	<span class="built_in">this</span>.orders = properties.stream()</span><br><span class="line">		.map(it -&gt; <span class="keyword">new</span> <span class="title class_">Order</span>(direction, it))</span><br><span class="line">		.collect(Collectors.toList());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pageable在查询的时候可以实现分页效果和动态排序双重效果，它的Structure如下<br><img src="https://raw.githubusercontent.com/yilan0916/picture/main/202306111159071.png" alt="截屏2023-06-11 11.59.02.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据分页参数查询User，返回一个带分页结果的Page对象</span></span><br><span class="line">Page&lt;User&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br><span class="line">Slice&lt;User&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br><span class="line">List&lt;User&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname, Sort sort)</span>;</span><br><span class="line">List&lt;User&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br></pre></td></tr></table></figure>
<p>方法一：允许将Pageable实例传递给查询方法，将分页参数添加到静态定义的查询中，通过Page返回的结果得知可用的元素和页面总数。这种分页查询方法可能是昂贵的（会默认执行一条count语句），所以用的时候要考虑一下使用场景<br>方法二：返回结果是Slice，因为只知道是否有下一个Slice可用，而不知道count，所以查询较大的结果集时，只知道数据时足够的，也就是说中业务场景中不用关心一共有多少页<br>方法三：如果只需要排序，需在Sort参数中添加一个参数，只需返回一个List也是可以的<br>方法四：排序选项也通过Pageable实例处理，在这种情况下，Page将不会构建实际实例所需的元素据（即不需要计算和查询分页相关的数据），而仅仅用来做限制查询给定范围的实体</p>
<p>因为Pageable是一个接口，无法创建实例，所以需要用PageRequest里面提供的静态方法（多态），分别构建页码、页面大小、排序等。<br><img src="https://raw.githubusercontent.com/yilan0916/picture/main/202306111922687.png" alt="截屏2023-06-11 19.20.31.png"></p>
<p>因为Sort不会创建实例，所有使用它的子类JpaSort，用法和PageRequest很像</p>
<p>在使用中的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询user里面lastname=yilan的第一页，每页大小是20条，并会返回一共有多少页的信息</span></span><br><span class="line">Page&lt;User&gt; users = userRepository.findByLastname(<span class="string">&quot;yilan&quot;</span>, PageRequest.of(<span class="number">1</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//查询user里面lastname=yilan的第一页，每页大小是20条，不知道一共多少条</span></span><br><span class="line">Slice&lt;User&gt; users = userRepository.findByLastname(<span class="string">&quot;yilan&quot;</span>, PageRequest.of(<span class="number">1</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//查询出来所有user里面lastname=yilan的数据，并按照name正序返回List</span></span><br><span class="line">List&lt;User&gt; users = userRepository.findByLastname(<span class="string">&quot;yilan&quot;</span>, JpaSort.of(Sort.Derection.ASC, <span class="string">&quot;name&quot;</span>）);</span><br></pre></td></tr></table></figure>

<h2 id="限制查询结果First和Top"><a href="#限制查询结果First和Top" class="headerlink" title="限制查询结果First和Top"></a>限制查询结果First和Top</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User <span class="title function_">findFirstByOrderLastnameAsc</span><span class="params">()</span>;</span><br><span class="line">User <span class="title function_">findTopByOrderByAgeDesc</span><span class="params">()</span>;</span><br><span class="line">List&lt;User&gt; <span class="title function_">findDistinctUserTop3ByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br><span class="line">List&lt;User&gt; <span class="title function_">findFirst10ByLastname</span><span class="params">(String lastname, Sort sort)</span>;</span><br><span class="line">List&lt;User&gt; <span class="title function_">findTop10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>查询方法在使用First或者Top时，数值可以追加到First和Top后面，指定返回最大结果的大小</li>
<li>如果数字被省略，则假设结果大小为1</li>
<li>限制表达式也支持Distinct关键字</li>
<li>支持将结果包装到Optional中</li>
<li>如果将Pageable作为参数，以Top和First后面的数据为准， 即分页将在限制结果中应用</li>
</ul>
<h2 id="Null参数注解"><a href="#Null参数注解" class="headerlink" title="Null参数注解"></a>Null参数注解</h2><p>从Spring Data2.0开始，JPA新增了@NonNull，@NonNullApi，@Nullable，是对null参数和返回结果做的支持</p>
<ul>
<li>@NonNullApi：在包级别用于声明参数，以及返回值的默认行为时不接受或产生空值的</li>
<li>@NonNul：用于不能为空的参数或返回值（在@NonNullApi适用的参数和返回值上不需要）</li>
<li>@Nullable：可以用于为空的参数或返回值</li>
</ul>
<p>package-info.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.lang.NonNullApi  </span><br><span class="line"><span class="keyword">package</span> com.yilan.user;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当我们添加@Nullable注解后，参数和返回结果这个时候就会允许为null了</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">User <span class="title function_">findByEmailAddress</span><span class="params">(<span class="meta">@Nullable</span> EmailAddress emailAddress)</span>;</span><br><span class="line"><span class="comment">//返回结果允许为null，参数不允许为null的情况</span></span><br><span class="line">Optional&lt;User&gt; <span class="title function_">findOptionalByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="给我们的一些思考"><a href="#给我们的一些思考" class="headerlink" title="给我们的一些思考"></a>给我们的一些思考</h2><p>在夜袭DQM的语法和其所表达的命名规范，在实际工作中，也可以将方法名（非常语义化的repository里面所定义的方法命名规范） 的强制约定规范运行到controller和service层，这样全部统一后，可以减少很多的沟通成本。</p>
<p>根据spring data commons里面的repository基类，推广到service层，建立自己的BaseSevice。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseService</span>&lt;T, ID&gt; &#123;</span><br><span class="line">    Class&lt;T&gt; <span class="title function_">getDomainClass</span><span class="params">()</span>;</span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">save</span><span class="params">(S entity)</span>;</span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">saveAll</span><span class="params">(Iterable&lt;S&gt; entities)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(T entity)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(ID id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">(Iterable&lt;? extends T&gt; entities)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteInBatch</span><span class="params">(Iterable&lt;T&gt; entities)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteAllInBatch</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">getOne</span><span class="params">(ID id)</span>;</span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; Optional&lt;S&gt; <span class="title function_">findOne</span><span class="params">(Example&lt;S&gt; example)</span>;</span><br><span class="line">    Optional&lt;T&gt; <span class="title function_">findById</span><span class="params">(ID id)</span>;</span><br><span class="line">    List&lt;T&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">    List&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Sort sort)</span>;</span><br><span class="line">    Page&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Pageable pageable)</span>;</span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">findAll</span><span class="params">(Example&lt;S&gt; example)</span>;</span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">findAll</span><span class="params">(Example&lt;S&gt; example, Sort sort)</span>;</span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; Page&lt;S&gt; <span class="title function_">findAll</span><span class="params">(Example&lt;S&gt; example, Pageable pageable)</span>;</span><br><span class="line">    List&lt;T&gt; <span class="title function_">findAllById</span><span class="params">(Iterable&lt;ID&gt; ids)</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; <span class="type">long</span> <span class="title function_">count</span><span class="params">(Example&lt;S&gt; example)</span>;</span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">(Example&lt;S&gt; example)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">existsById</span><span class="params">(ID id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">saveAndFlush</span><span class="params">(S entity)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们模仿JpaRepository接口也自定义了一个自己的BaseService，声明了常用的CRUD操作，上面的代码是生产代码，可以作为参考。当然了我们也可以建立自己的 PagingAndSortingService、ComplexityService、SampleService 等来划分不同的 service接口，供不同目的 Service 子类继承。</p>
<p>我们再来模仿一个 SimpleJpaRepository，来实现自己的 BaseService 的实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseServiceImpl</span>&lt;T, ID, R <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;T, ID&gt;&gt; <span class="keyword">implements</span> <span class="title class_">BaseService</span>&lt;T, ID&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class, Class&gt; DOMAIN_CLASS_CACHE = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> R repository;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseServiceImpl</span><span class="params">(R repository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;T&gt; <span class="title function_">getDomainClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">thisClass</span> <span class="operator">=</span> getClass();</span><br><span class="line">        Class&lt;T&gt; domainClass = DOMAIN_CLASS_CACHE.get(thisClass);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(domainClass)) &#123;</span><br><span class="line">            domainClass = GenericsUtils.getGenericClass(thisClass, <span class="number">0</span>);</span><br><span class="line">            DOMAIN_CLASS_CACHE.putIfAbsent(thisClass, domainClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> domainClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> R <span class="title function_">getRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">save</span><span class="params">(S entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.save(entity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">saveAll</span><span class="params">(Iterable&lt;S&gt; entities)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.saveAll(entities);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        repository.delete(entity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(ID id)</span> &#123;</span><br><span class="line">        repository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">()</span> &#123;</span><br><span class="line">        repository.deleteAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">(Iterable&lt;? extends T&gt; entities)</span> &#123;</span><br><span class="line">        repository.deleteAll(entities);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteInBatch</span><span class="params">(Iterable&lt;T&gt; entities)</span> &#123;</span><br><span class="line">        repository.deleteInBatch(entities);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAllInBatch</span><span class="params">()</span> &#123;</span><br><span class="line">        repository.deleteAllInBatch();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getOne</span><span class="params">(ID id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.getOne(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; Optional&lt;S&gt; <span class="title function_">findOne</span><span class="params">(Example&lt;S&gt; example)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findOne(example);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">findById</span><span class="params">(ID id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Sort sort)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findAll(sort);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Page&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Pageable pageable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findAll(pageable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">findAll</span><span class="params">(Example&lt;S&gt; example)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findAll(example);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">findAll</span><span class="params">(Example&lt;S&gt; example, Sort sort)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findAll(example, sort);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; Page&lt;S&gt; <span class="title function_">findAll</span><span class="params">(Example&lt;S&gt; example, Pageable pageable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findAll(example, pageable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">findAllById</span><span class="params">(Iterable&lt;ID&gt; ids)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findAllById(ids);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.count();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; <span class="type">long</span> <span class="title function_">count</span><span class="params">(Example&lt;S&gt; example)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.count(example);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">(Example&lt;S&gt; example)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.exists(example);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">existsById</span><span class="params">(ID id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.existsById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> &#123;</span><br><span class="line">        repository.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">saveAndFlush</span><span class="params">(S entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> repository.saveAndFlush(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就是 BaseService 常用的 CURD 实现代码，我们这里面大部分也是直接调用 Repository 提供的方法。需要注意的是，当继承 BaseServiceImpl 的时候需要传递自己的 Repository，如下面实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">BaseServiceImpl</span>&lt;User, Long, UserRepository&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserRepository repository)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(repository);</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Repository的方法返回值解决实际问题"><a href="#Repository的方法返回值解决实际问题" class="headerlink" title="Repository的方法返回值解决实际问题"></a>Repository的方法返回值解决实际问题</h1><p>打开SimpleJpaRepository，它的实现方法支持的返回类型包括：Optiona、Iterable、List、Page、Long、Boolean、Entity等<br>由于Repository支持Iterable，所以其他java标准等List、Set都可以作为返回结果，并且也支持其子类<br>Spring Data中定义了特殊的子类Streamable，Streamable可以替代Iterable或任何集合类型。它还提供了方便方法Stream，可以直接在元素上进行…filter(…)和…map(…)操作，并将Streamable连接到其他元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.save(User.builder().name(<span class="string">&quot;jack002&quot;</span>).email(<span class="string">&quot;jack002&#x27;s email&quot;</span>).build());  </span><br><span class="line">Assert.notNull(user, <span class="string">&quot;user插入失败&quot;</span>);  </span><br><span class="line">Streamable&lt;User&gt; userStreamable = userRepository.findAll(PageRequest.of(<span class="number">1</span>, <span class="number">10</span>)).and(User.builder().name(<span class="string">&quot;yilan666&quot;</span>).build());  </span><br><span class="line">userStreamable.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>在实际工作中，官方提供的Streamable的方法已经足够用了</p>
<h2 id="如何返回List-x2F-Stream-x2F-Page-x2F-Slice"><a href="#如何返回List-x2F-Stream-x2F-Page-x2F-Slice" class="headerlink" title="如何返回List&#x2F;Stream&#x2F;Page&#x2F;Slice"></a>如何返回List&#x2F;Stream&#x2F;Page&#x2F;Slice</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">	<span class="comment">//我们新增7条数据方便测试分页结果</span></span><br><span class="line">	userRepository.save(User.builder().name(<span class="string">&quot;jack1&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>).sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">	userRepository.save(User.builder().name(<span class="string">&quot;jack2&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>).sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">	userRepository.save(User.builder().name(<span class="string">&quot;jack3&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>).sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">	userRepository.save(User.builder().name(<span class="string">&quot;jack4&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>).sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">	userRepository.save(User.builder().name(<span class="string">&quot;jack5&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>).sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">	userRepository.save(User.builder().name(<span class="string">&quot;jack6&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>).sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">	userRepository.save(User.builder().name(<span class="string">&quot;jack7&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>).sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">	<span class="comment">//我们利用ObjectMapper将我们的返回结果Json to String</span></span><br><span class="line">	<span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">	<span class="comment">//返回Stream类型结果（1）</span></span><br><span class="line">	Stream&lt;User&gt; userStream = userRepository.findAllByCustomQueryAndStream(PageRequest.of(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">	userStream.forEach(System.out::println);</span><br><span class="line">	<span class="comment">//返回分页数据（2）</span></span><br><span class="line">	Page&lt;User&gt; userPage = userRepository.findAll(PageRequest.of(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">	System.out.println(objectMapper.writeValueAsString(userPage));</span><br><span class="line">	<span class="comment">//返回Slice结果（3）</span></span><br><span class="line">	Slice&lt;User&gt; userSlice = userRepository.findAllByCustomQueryAndSlice(PageRequest.of(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">	System.out.println(objectMapper.writeValueAsString(userSlice));</span><br><span class="line">	<span class="comment">//返回List结果（4）</span></span><br><span class="line">	List&lt;User&gt; userList = userRepository.findAllById(Lists.newArrayList(<span class="number">1L</span>,<span class="number">2L</span>));</span><br><span class="line">	System.out.println(objectMapper.writeValueAsString(userList));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种：通过<code>Stream&lt;User&gt;</code>取第二页的数据<br>Spring Data 的支持可以通过使用 Java 8 Stream 作为返回类型来逐步处理查询方法的结果。需要注意的是：流的关闭问题，try catch 是一种常用的关闭方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;User&gt; stream;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   stream = repository.findAllByCustomQueryAndStream()</span><br><span class="line">   stream.forEach(…);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (stream!=<span class="literal">null</span>)&#123;</span><br><span class="line">      stream.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐try-with-resource</span></span><br><span class="line"><span class="keyword">try</span> (Stream&lt;User&gt; stream = userRepository.findAllByCustomQueryAndStream()) &#123;  </span><br><span class="line">	...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：返回<code>Page&lt;User&gt;</code>的分页结果<br>这里我们可以看到 Page<code>&lt;User&gt;</code> 返回了第一个页的数据，并且告诉我们一共有三个部分的数据：</p>
<ul>
<li><strong>content</strong>：数据的内容，现在指 User 的 List 3 条。</li>
<li><strong>pageable</strong>：分页数据，包括排序字段是什么及其方向、当前是第几页、一共多少页、是否是最后一条等。</li>
<li><strong>当前数据的描述</strong>：“size”：3，当前 content 大小；“number”：0，当前页面码的索引；  “first”：true，是否是第一页；“empty”：false，是否没有数据。</li>
</ul>
<p>第三种：返回 Slice<code>&lt;User&gt;</code> 结果</p>
<p>这时我们发现上面的 Page 返回结果少了，那么一共有多少条结果、多少页的数据呢？我们再比较一下第二种和第三种测试结果的执行 SQL：</p>
<ul>
<li>第二种执行的是普通的分页查询 SQL：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询分页数据</span><br><span class="line">Hibernate: <span class="keyword">select</span> user0_.id <span class="keyword">as</span> id1_0_, user0_.address <span class="keyword">as</span> address2_0_, user0_.email <span class="keyword">as</span> email3_0_, user0_.name <span class="keyword">as</span> name4_0_, user0_.sex <span class="keyword">as</span> sex5_0_ <span class="keyword">from</span> <span class="keyword">user</span> user0_ limit ?</span><br><span class="line">计算分页数据</span><br><span class="line">Hibernate: <span class="keyword">select</span> <span class="built_in">count</span>(user0_.id) <span class="keyword">as</span> col_0_0_ <span class="keyword">from</span> <span class="keyword">user</span> user0_</span><br></pre></td></tr></table></figure>

<ul>
<li>第三种执行的 SQL 如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: <span class="keyword">select</span> user0_.id <span class="keyword">as</span> id1_0_, user0_.address <span class="keyword">as</span> address2_0_, user0_.email <span class="keyword">as</span> email3_0_, user0_.name <span class="keyword">as</span> name4_0_, user0_.sex <span class="keyword">as</span> sex5_0_ <span class="keyword">from</span> <span class="keyword">user</span> user0_ limit ? <span class="keyword">offset</span> ?</span><br></pre></td></tr></table></figure>

<p>通过对比可以看出，只查询偏移量，不计算分页数据，这就是 Page 和 Slice 的主要区别</p>
<p>第四种：返回普通的List数据，没有分页信息</p>
<h2 id="Repository-的方法是如何对异步进行支持"><a href="#Repository-的方法是如何对异步进行支持" class="headerlink" title="Repository 的方法是如何对异步进行支持"></a>Repository 的方法是如何对异步进行支持</h2><p>Repository 对 Feature&#x2F;CompletableFuture 异步返回结果的支持：</p>
<p>我们可以使用 Spring 的异步方法执行Repository查询，这意味着方法将在调用时立即返回，并且实际的查询执行将发生在已提交给 Spring TaskExecutor 的任务中，比较适合定时任务的实际场景。异步使用起来比较简单，直接加@Async 注解即可，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line">Future&lt;User&gt; <span class="title function_">findByFirstname</span><span class="params">(String firstname)</span>; (<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line">CompletableFuture&lt;User&gt; <span class="title function_">findOneByFirstname</span><span class="params">(String firstname)</span>; (<span class="number">2</span>)</span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line">ListenableFuture&lt;User&gt; <span class="title function_">findOneByLastname</span><span class="params">(String lastname)</span>;(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>上述三个异步方法的返回结果，分别做如下解释：</p>
<ul>
<li>第一处：使用 java.util.concurrent.Future 的返回类型；</li>
<li>第二处：使用 java.util.concurrent.CompletableFuture 作为返回类型；</li>
<li>第三处：使用 org.springframework.util.concurrent.ListenableFuture 作为返回类型。</li>
</ul>
<p>以上是对 @Async 的支持，关于实际使用需要注意以下三点内容：</p>
<ul>
<li>在实际工作中，直接在 Repository 这一层使用异步方法的场景不多，一般都是把异步注解放在 Service 的方法上面，这样的话，可以有一些额外逻辑，如发短信、发邮件、发消息等配合使用；</li>
<li>使用异步的时候一定要配置线程池，这点切记，否则“死”得会很难看； </li>
<li>万一失败我们会怎么处理？关于事务是怎么处理的呢？这种需要重点考虑的，我将会在 14 课时（乐观锁机制和重试机制在实战中应该怎么用?）中详细介绍。</li>
</ul>
<h2 id="Repository-对Reactive-是如何支持的"><a href="#Repository-对Reactive-是如何支持的" class="headerlink" title="Repository 对Reactive 是如何支持的"></a>Repository 对Reactive 是如何支持的</h2><p>看到Spring Data Common里面对React还是有支持的，那为什么在JpaRespository里面没看到有响应的返回结果支持呢？其实Common里面提供的只是接口，而JPA里面没有做相关的Reactive 的实现，但是本身Spring Data Common里面对 Reactive 是支持的。</p>
<p>下面我们在 gradle 里面引用一个Spring Data Common的子模块implementation ‘org.springframework.boot:spring-boot-starter-data-mongodb’ 来加载依赖，这时候我们打开 Repository 看 Hierarchy 就可以看到，这里多了一个 Mongo 的 Repsitory 的实现，天然地支持着 Reactive 这条线。</p>
<h2 id="返回结果支持总结"><a href="#返回结果支持总结" class="headerlink" title="返回结果支持总结"></a>返回结果支持总结</h2><p>下面打开 ResultProcessor 类的源码看一下支持的类型有哪些。<br>可以看出 processResult 的时候分别对 PageQuery、Stream、Reactiv 有了各自的判断，我们 debug 到这里的时候来看一下 convert，进入到类里面。可以看到 QueryExecutorConverters 里面对 JDK8、Guava、vavr 也做了各种支持，如果你有兴趣可以课后去仔细看看源码。</p>
<p>这里我们先用表格总结一下返回值，下表列出了 Spring Data JPA Query Method 机制支持的方法的返回值类型：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/56/1D/Ciqc1F9rDAiARh9tAAQVFWlht1s532.png" alt="Drawing 5.png"></p>
<h2 id="最常见的DTO返回结果的支持"><a href="#最常见的DTO返回结果的支持" class="headerlink" title="最常见的DTO返回结果的支持"></a>最常见的DTO返回结果的支持</h2><p>第一种方法：新建一张表的不同 Entity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOnlyNameEmailEntity</span> &#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一个 UserOnlyNameEmailEntityRepository，做单独的查询</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserOnlyNameEmailEntityRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;UserOnlyNameEmailEntity,Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式的好处是简单、方便，很容易可以想到；缺点就是通过两个实体都可以进行 update 操作，如果同一个项目里面这种实体比较多，到时候就容易不知道是谁更新的，从而导致出 bug 不好查询，实体职责划分不明确。</p>
<p>第二种方法：直接定义一个 UserOnlyNameEmailDto</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOnlyNameEmailDto</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name,email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 UserRepository 里面做如下用法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User,Long&gt; &#123;</span><br><span class="line">    <span class="comment">//测试只返回name和email的DTO</span></span><br><span class="line">    UserOnlyNameEmailDto <span class="title function_">findByEmail</span><span class="params">(String email)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，如果我们去看源码的话，看关键的 PreferredConstructorDiscoverer 类时会发现，UserDTO 里面只能有一个全参数构造方法</p>
<p>如上图所示，Constructor 选择的时候会帮我们做构造参数的选择，如果 DTO 里面有多个构造方法，就会报转化错误的异常，这一点需要注意，异常是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No converter found capable of converting from type [com.example.jpa.example1.User] to type [com.example.jpa.example1.UserOnlyNameEmailDto</span><br></pre></td></tr></table></figure>

<p>所以这种方式的优点就是返回的结果不需要是个实体对象，对 DB 不能进行除了查询之外的任何操作；缺点就是有 set 方法还可以改变里面的值，构造方法不能更改，必须全参数，这样如果是不熟悉 JPA 的新人操作的时候很容易引发 Bug。</p>
<p> 第三种方法：返回结果是一个 POJO 的接口</p>
<p>我们再来学习一种返回不同字段的方式，这种方式与上面两种的区别是只需要定义接口，它的好处是只读，不需要添加构造方法，我们使用起来非常灵活，一般很难产生 Bug，那么它怎么实现呢？</p>
<p>首先，定义一个 UserOnlyName 的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserOnlyName</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getEmail</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，我们的 UserRepository 写法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User,Long&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口的方式返回DTO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> address</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UserOnlyName <span class="title function_">findByAddress</span><span class="params">(String address)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候会发现我们的 userOnlyName 接口成了一个代理对象，里面通过 Map 的格式包含了我们的要返回字段的值（如：name、email），我们用的时候直接调用接口里面的方法即可，如 userOnlyName.getName() 即可；这种方式的优点是接口为只读，并且语义更清晰，所以这种是比较推荐的做法。</p>
<h1 id="Query注解"><a href="#Query注解" class="headerlink" title="@Query注解"></a>@Query注解</h1><h2 id="注解源码"><a href="#注解源码" class="headerlink" title="注解源码"></a>注解源码</h2><p>在讲解它的语法之前，我们看一下它的注解源码，了解一下基本用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.data.jpa.repository;</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Query &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定JPQL的查询语句。（nativeQuery=true的时候，是原生的Sql语句）</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">   String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 指定count的JPQL语句，如果不指定将根据query自动生成。</span></span><br><span class="line"><span class="comment">    * （如果当nativeQuery=true的时候，指的是原生的Sql语句）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   String <span class="title function_">countQuery</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据哪个字段来count，一般默认即可。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">   String <span class="title function_">countProjection</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认是false，表示value里面是不是原生的sql语句</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">nativeQuery</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 可以指定一个query的名字，必须唯一的。</span></span><br><span class="line"><span class="comment">	* 如果不指定，默认的生成规则是：</span></span><br><span class="line"><span class="comment">    * &#123;$domainClass&#125;.$&#123;queryMethodName&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 可以指定一个count的query的名字，必须唯一的。</span></span><br><span class="line"><span class="comment">	* 如果不指定，默认的生成规则是：</span></span><br><span class="line"><span class="comment">    * &#123;$domainClass&#125;.$&#123;queryMethodName&#125;.count</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   String <span class="title function_">countName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Query 用法是使用 JPQL 为实体创建声明式查询方法。我们一般只需要关心 @Query 里面的 value 和 nativeQuery、countQuery 的值即可，因为其他的不常用。</p>
<p>使用声明式 JPQL 查询有个好处，就是启动的时候就知道你的语法正确不正确。那么我们简单介绍一下 JPQL 语法。</p>
<h2 id="JPQL-的语法"><a href="#JPQL-的语法" class="headerlink" title="JPQL 的语法"></a>JPQL 的语法</h2><p>查询的语法结构，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM ...</span><br><span class="line">[WHERE ...]</span><br><span class="line">[GROUP BY ... [HAVING ...]]</span><br><span class="line">[ORDER BY ...]</span><br></pre></td></tr></table></figure>
<p>你会发现它的语法结构有点类似我们 SQL，唯一的区别就是 JPQL FROM 后面跟的是对象，而 SQL 里面的字段对应的是对象里面的属性字段。<br>同理我们看一下 update 和 delete 的语法结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM ... [WHERE ...]</span><br><span class="line">UPDATE ... SET ... [WHERE ...]</span><br></pre></td></tr></table></figure>

<p>其中“…”省略的部分是实体对象名字和实体对象里面的字段名字，而其中类似 SQL 一样包含的语法关键字有：SELECT  FROM  WHERE  UPDATE  DELETE  JOIN  OUTER  INNER  LEFT  GROUP  BY  HAVING等关键字</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>resources下创建.http文件可以测试接口</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:yilan0916@gmail.com">yilan0916</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yilan0916.github.io/2023/06/10/Blogs/Java/Spring/Spring Data JPA/">https://yilan0916.github.io/2023/06/10/Blogs/Java/Spring/Spring Data JPA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yilan0916.github.io">yilan0916's Blogs</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Spring/">Spring</a><a class="post-meta__tags" href="/tags/Spring-Data-JPA/">Spring Data JPA</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/06/22/Blogs/Java/Spring/Spring%20Boot/"><i class="fa fa-chevron-left">  </i><span>Spring Boot</span></a></div><div class="next-post pull-right"><a href="/2023/06/09/Blogs/Java/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/IDEA%E8%AE%BE%E7%BD%AE/"><span>IDEA设置</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '9ffd1e4033bdf26f61b2',
  clientSecret: '40d17299ec8cb68e1ab56dd11a08f730fdc50d09',
  repo: 'yilan0916.github.io',
  owner: 'yilan0916',
  admin: 'yilan0916',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2022 - 2024 By yilan0916</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>